<!DOCTYPE html>
<head>
  <title>Natalia's Blog Post</title>
  <meta charset="UTF-8">
  <link rel="stylesheet" type="text/css" href="../stylesheets/default.css"/>
  <link rel="stylesheet" type="text/css" href="../stylesheets/blog-stylesheet.css"/>
</head>

<body>

  <div class="homebutton"><a href="../index.html">Home</a></div>
  <div class="blogbutton"><a href="./blog_index.html">Blog</a></div>
  <h1 class="heading">Natalia's Technical Blog</h1>
  <h2 class="heading">Post 4. Ruby classes</h2>
  <h4 class="heading">January 2,2015</h4>



  <section class="blogbody">


      <p><code><pre>class Drink
        attr_accessor :price, :taste, :causes_hangover?, :low_calorie?
        attr_reader :name
          def initialize(name)
            @name = name
          end
          def print_info
           if @causes_hangover? == true
             p "it might give you leave you with headache on the next day"
             p "Don't drink it unless you are 21 or older"
           end
           if @low_calorie? == true
             p "The good thing about it, you don't have to worry about calories"
           end
          end
          mojito=Drink.new("Mojito")
          mojito.taste = "soursweet"
          mojito.causes_hangover = true
          mojito.low_calorie = false
        end</code></pre></p>

    <p>Classes are like prototipes for ruby objects. They define properties and methods that instances of a class will have. Not that any object can't have it's own properties - you always can define unique methods for any one object, that not any other object will have. But , if you know that you will be creating lots of objects that will need to respond to certain method(s), it make sense to define class, define methods that all instanses of that class will have, and than create as many instances of that class as needed, with simple "object_name = Class_name.new" command</p>
    <p>In my case, I created class Drink, and supply methods to it.The visible methods are "#initialize" , which is called with "class_name.new" command, and "#print_info" method, that prints information about a drink . </p>
    <p>
      Besides this, I have other methods, that I can call on all instances of class drink thanks to attr_reader and attr_accessor (these are methods of class Drink itself, not of its instances). Then , by providing arguments to attr_reader we now have methods #name, #price, #taste and such(called getter methods). attr_reader give us both getter methods, and setter methods, that looks like #price=, #low_calorie=, and so on. Thanks to this methods, we can any time set price of a drink, like "cosmo.price=56", or find the taste of it ("milk.taste").
      <p> Another cool thing about classes, they can relate to each other. Here is example:
      </p>
      <p><pre><code>
        class Soda < Drink
         def some_method
           .......
         end
         def some_other_method
           .......
         end
        end
      </code></pre></p>
      <p>Here we created another class Soda, and it is a subclass of Drink. So all instances of Soda will have the methods defined in Drink (unless we decide to override them). But as well Soda's instances will have methods defined only in Soda class. To find methods that class defines for its instances(without methods defined in superclass), you can use command "Class_name.instance_methods(false)".</p>
      <p> Along with getting methods from its class, or superclass of the class, and its singleton(unique) methods , object can get methods from modules that are mixed in class. Modules are pretty much like classes, in a way that they are define methods that objects can use. But, modues themselves cannot create object(they don't have method ".new", like classes). So in order to be able to use methods defined in modules, we mix module in a class, and then create instances of that class.</p>
      <p>It is important to remember , that classes are objects too, and you can call methods on them and these will be different methods than methods you call on their instances. For exaple, we call method ".new"  on a class when we create its instance. Another example- you can check whether a class has certain module mixed-in, with "Class_name.include?(Module_name)" method. To see the difference bettween class methods and instance methods,  run "Array.methods" and "Array.instance_methods"(or Array.instance_methods(false)) in irb.</p>
  </section>

</body>
</html>

